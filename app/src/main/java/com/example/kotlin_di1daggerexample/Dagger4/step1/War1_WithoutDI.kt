package com.example.kotlin_di1daggerexample.Dagger4.step1

// Приводим оба дома к войне. Создадим класс War1_WithoutDI и попросим оба дома подготовиться к войне и сообщить о ней
class War1_WithoutDI {
    private val starks = Starks()
    private val boltons = Boltons()

    init {
        starks.prepareForWar()
        starks.reportForWar()
        boltons.prepareForWar()
        boltons.reportForWar()
    }
}

// Рассмотрим класс War1_WithoutDI. Для работы ему необходимы два класса Starks и Boltons. Эти классы создаются
// внутри класса War1_WithoutDI, готовятся к войне и сообщают о ней.
// В данном примере класс War зависит от Starks и Boltons. Это зависимости класса War1_WithoutDI. Без них War работать не будет.

// Перед тем как класс начнет выполнять реальные функции, все его зависимости должны быть удовлетворены
// каким-либо образом. Зависимости класса War в этом примере удовлетворяются путем создания экземпляров классов
// в конструкторе.

// В данном случае есть недостатки:
// Во-первых, класс становится довольно негибким. Если приложение должно работать на нескольких платформах или
// в нескольких режимах, например, необходимо заменить класс Boltonsна другой или разделить его на несколько объектов.
// Сделать это становится не так просто.
// Во-вторых, невозможно изолированно протестировать эти классы. Создание экземпляра War автоматически создает
// два других объекта, которые, в конечном итоге, будут тестироваться вместе с классом War1_WithoutDI. Это может стать проблемой,
// если один из объектов зависит от дорогого внешнего ресурса, например, Allies (союзники) или один из объектов сам
// зависит от множества других.