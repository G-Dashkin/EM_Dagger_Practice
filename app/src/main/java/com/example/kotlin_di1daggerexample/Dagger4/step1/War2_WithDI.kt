package com.example.kotlin_di1daggerexample.Dagger4.step1

// Теперь используем внедрение зависимостей, чтобы устранить сильные связи.
// Идея внедрения зависимостей - Класс не должен создавать другие классы. Вместо этого он должен получать
// зависимости снаружи. Получаем зависимости Boltons и Starks снаружи, через конструктор класса War
class War2_WithDI(
    private val starks: Starks,
    private val boltons: Boltons
) {
    fun prepare() {
        starks.prepareForWar()
        boltons.prepareForWar()
    }

    fun report() {
        starks.reportForWar()
        boltons.reportForWar()
    }
}

// Это вариант внедрения зависимостей через конструктор. Многие используют концепцию внедрения
// зависимостей, не подозревая об этом.

// Класс War2_WithDI должен знать не только о том, как выполнить определенную задачу, но и о том, где
// искать классы, в которых он нуждается для выполнения своих задач. Если мы предоставим всё необходимое
// для работы нашему классу снаружи, то избавимся от ранее рассмотренных проблем. Класс легко сможет
// работать с любыми экземплярами других классов, которые нужны ему для выполнения задач, и будет
// просто тестироваться в изоляции от них. В приложении, использующем внедрение зависимостей, объекты
// никогда не будут искать зависимости или создавать их внутри себя. Все зависимости предоставляются
// ему или внедряются в него готовыми к использованию.

// В какой-то момент, конечно, кто-то должен создать экземпляры классов зависимостей и предоставить
// их объектам, которые в этом нуждаются. Обычно такая работа выполняется в точке входа в приложение.
// В обычном Kotlin коде, например, такой код можно найти внутри метода main(), как показано ниже.
// В Android это обычно делается в методе onCreate() внутри Activity.