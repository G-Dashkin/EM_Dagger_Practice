Dagger 2 — это один из фреймворков с открытым исходным кодом для внедрения зависимостей, который
генерирует большое количество шаблонного кода за вас. Сейчас это единственный DI фреймворк, который
генерирует полностью отслеживаемый Java код, имитирующий тот код, который вы могли написать вручную.
Это означает, что в построении графа зависимостей нет никакой магии. Dagger 2 менее динамичен, чем
другие (в нем не используется рефлексия), но простота и производительность сгенерированного кода
находятся на том же уровне, что и у написанного вручную. Коротко, Dagger 2 генерирует весь шаблонный
код для внедрения зависимостей за вас.

Ручное управление зависимостями — это как добыча драконьего стекла. Сначала вы получаете разрешение
от королевы драконов, затем куете оружие и только потом идете воевать с Белыми Ходоками (проблемами
сильных связей). Dagger 2 похож на валирийский меч — он был создан мастерами, и всё, что вам нужно,
— просто использовать его.

Аннотации — это вид метаданных, который может быть связан с классами, методами, полями и даже другими
аннотациями. Аннотации используются в Java для предоставления дополнительной информации, как альтернатива
XML или маркерным интерфейсам (пустые интерфейсы). К аннотациям можно получить доступ и в процессе
выполнения программы (runtime) через механизм рефлексии.

Обработчики аннотаций (Annotation Processors)
Обработчики аннотаций — это генераторы кода, которые скрывают от вас шаблонный код, создавая его за вас
во время компиляции. Пока эти действия выполняются во время компиляции, никакого отрицательного влияния
на производительность нет.

Dagger 2 использует "Обработчики аннотаций". Таким образом можно отследить весь сгенерированный код
во время компиляции. Следовательно, нет ухудшения производительности, а ошибки легко отслеживаются.
Пример аннотации в Java @Override. Если вы использовали Butterknife, @BindView — это тоже аннотация,
которая скрывает за собой некоторые метаданные, помогающие генерировать код.

Аннотации Dagger 2
@Inject
Это наиболее важная аннотация. JSR-330 определяет данную аннотацию как пометку для зависимостей,
которые должны быть предоставлены фреймворком для внедрения зависимостей.
Внедрение в конструктор (Constructor Injection) — используется с конструктором класса.
Внедрение в поле (Field Injection) — используется с полями класса.
Внедрение в метод (Method Injection ) — используется с методами.

Примеры ниже,
_________________________________________________________________
class Starks @Inject constructor(      // Внедрение в конструктор
   allies: Allies
) {

    @Inject                            // Внедрение в поле
    lateinit var allies: Allies

    @Inject                             // Внедрение в метод
    fun prepareForWar(allies: Allies) {
        // что-то происходит
    }
}
_________________________________________________________________

Аннотация @Inject сообщит Dagger, какие зависимости должны быть предоставлены зависимому объекту.
Это как агенты железного банка, которые ведут переговоры с домами и определяют сумму кредита, которую
могут предоставить дому.

@Component
Это аннотация используется для интерфейса, который объединит все части процесса внедрения зависимостей.
При использовании данной аннотации мы определяем, из каких модулей или других компонентов будут браться
зависимости. Также здесь можно определить, какие зависимости будут видны открыто (могут быть внедрены)
и где компонент может внедрять объекты. @Component, в общем, что-то вроде моста между @Module (рассмотрим
эту аннотацию позже) и @Inject.
Другими словами, эта аннотация как агент железного банка, который отвечает за утверждение кредита и
перевод денег на соответствующий счет.