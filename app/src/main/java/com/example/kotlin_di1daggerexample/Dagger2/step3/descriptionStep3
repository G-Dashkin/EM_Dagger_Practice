Теперь реализуем работу при помощи внедрения зависимостей

- Аннотации @Inject добавлена в базу данных ExampleDatabase с пустым конструктором, так как она
  ничего не принимает в конструктор. Теперь даггер умеет создавать экземпляр базы данных.
- То же самое сделаем для api-сервисом ExampleApiService, добавляем аннотацию @Inject

- Далее идет источник данных - ExampleLocalDataSourceImpl. Он в качестве параметра принимает базу
  данных ExampleDatabase и Dagger умеет ее создавать. Поэтому на этот конструктор так же навешиваем
  аннотацию @Inject
- Тоже самое для ExampleRemoteDataSourceImpl

- На интерфейсы ExampleLocalDataSource и ExampleRemoteDataSource мы не можем навесить аннотацию @Inject,
  так как это интерфейс и у них нет никакого конструктора и ничего добавить здесь не получится.

- Далее у нас идет мапре ExampleMapper с пустым конструктором, добавляем @Inject

- Добавляем аннотацию @Inject в репозиторий ExampleRepositoryImpl. На реализациях интрефейсов
  ExampleLocalDataSource, ExampleRemoteDataSource и ExampleMapper аннотация @Inject уже есть.

- Добавляем аннотацию @Inject в юзкейс ExampleUseCase

- И добавляем аннотацию @Inject в класс ExampleViewModel

- Сейчас у нас нет доступа к конструктору активити и мы не можем инжектить туда вьюМодель.
  Поэтому используем инъекцию в поля активити. И у нас все должно работать.

- Создаем компонент (интерфейс коммонента) ApplicationComponent в отдельном пакете - di, который
  присвоит значение полю viewModel и навешиваем аннотацию @Component
- Создаем метод inject(), который принимает активити и ничего не возвращает. Не обязательно, чтобы
  метод назывался inject(), главное, чтобы это был метод с одним параметром и ничего не возвращал.
- Важно!!! метод inject() принимает именно ActivityStep3, а не AppCompatActivity так как в реализации
  этого метода Dagger будет обращаться к реализации ViewModel и присваивать ему какое то значение.
  В классе MainActivity такое поле есть, а в классе AppCompatActivity такого поля нет.

- Далее, нам нужно заинжектить интерфейсы, но у них нет конструкторов.
  даггер не может сам догадаться, какую реализацию подставить, если в качестве параметра используется
  интерфейс. Нам нужен метод помеченный аннотацией @Provides, который предоставляет реализацию репозитория
  ExampleRepositoryImpl, тоже самое для ExampleLocalDataSourceImpl и ExampleRemoteDataSourceImpl

- Реализацию всех зависимостей можно указать в одном модуле, но это не очень хорошо, так как класс
  может стать очень огромным. Мы создадим два модуля, каждый из которых будет отвечать за свою область.
- Создадим модуль для data-слоя в пакете di назовем - DataModule с аннотацией @Module
- И создадим модуль для domain-слоя - DomainModule

- Далее, в пакете domain нам нужна реализация репозитория,
  Создаем provide-метод, пометим аннотацией @Provide, он будет возвращать тип ExampleRepository и
  создавать реализацию этого интерфейса - ExampleRepositoryImpl()
  и в этом provide-метод мы можем передаем реализацию в конструктро, чтобы вернуть ее через return
  в качестве параметра передаем реализацию репозитория ExampleRepositoryImpl
- Тоже самое делаем с дата-модулем DataModule

- и оба этих модуля, добавляем в ApplicationComponent

- Собираем проект,

- Создаем компонент в активити и методе onCreate() можно делать инжект. Обычно это делается перед
  вызовом super.onCreate(), для того, чтобы у нас точно были проинициализированы все необходимые поля,
  когда активити будет создано.


- Запускаем приложение и у нас все работает без ручной инициализации вьюМодели

  Мы добились того, что при запуске приложения у нас в лог выводится сообщения - "ExampleDatabase"
  и "ExampleApiService"

